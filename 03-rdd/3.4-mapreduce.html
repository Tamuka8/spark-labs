<p><link rel='stylesheet' href='../assets/css/main.css'/></p>
<p>&lt;&lt; <a href="../README.md">back to main index</a></p>
<h1 id="lab-3.4-map-reduce">Lab 3.4: Map Reduce</h1>
<h3 id="overview">Overview</h3>
<p>Learn MapReduce in Spark step by step</p>
<h3 id="depends-on">Depends On</h3>
<p>None</p>
<h3 id="run-time">Run time</h3>
<p>20 mins</p>
<table>
<tbody>
<tr class="odd">
<td>STEP 1: Launch Spark Shell</td>
</tr>
</tbody>
</table>
<pre><code>$   ~/spark/bin/spark-shell</code></pre>
<p><strong>=&gt; Make an RDD</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" data-line-number="1">    <span class="co">// scala</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="kw">val</span> input = Array (<span class="st">&quot;hello world&quot;</span>, <span class="st">&quot;good bye world&quot;</span>, <span class="st">&quot;ok bye&quot;</span>)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">val</span> r = sc.<span class="fu">makeRDD</span>(input)    <span class="co">// this works in the same way as &#39;parallelize&#39;</span></a></code></pre></div>
<p><strong>=&gt; Add up the words and counts</strong></p>
<table style="width:18%;">
<colgroup>
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th>STEP 2 : Map</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>=&gt; Apply <code>map()</code> function to rdd</strong></td>
</tr>
<tr class="even">
<td>val r2 = r.map(line =&gt; line.split(&quot; &quot;))</td>
</tr>
<tr class="odd">
<td><strong>=&gt; Print out the results by <code>collect()</code></strong> <strong>=&gt; Notice the resulting RDD type</strong></td>
</tr>
</tbody>
</table>
<h2 id="step-3-flatmap">STEP 3: flatMap</h2>
<p><strong>=&gt; Use <code>flatMap</code> to create another RDD</strong></p>
<pre><code>val r3 = r.flatMap( line =&gt; line.split(&quot; &quot;))</code></pre>
<p><strong>=&gt; Print out the results, can you explain the data type</strong></p>
<table style="width:32%;">
<colgroup>
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>STEP 4: Create KV pair</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>=&gt; Create a key-value pair by using <code>flatMap</code> and <code>map</code></strong></td>
</tr>
<tr class="even">
<td>val r4 = r.flatMap(line =&gt; line.split(&quot; &quot;)).map(word =&gt; (word, 1))</td>
</tr>
</tbody>
</table>
<h2 id="step-5-reducebykey">STEP 5: reduceByKey</h2>
<p><strong>=&gt; Add up the words and counts</strong></p>
<pre><code>val r5 = r4.reduceByKey((a,b) =&gt; a+b)</code></pre>
<table style="width:35%;">
<colgroup>
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>STEP 6: [Optional] Generating data</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>If not there already, we can generate some data</td>
</tr>
<tr class="even">
<td>$ cd /data/text/twinkle $ ./create-data-files.sh</td>
</tr>
<tr class="odd">
<td>This script will generate a bunch of data files at various sizes (1M, 10M, 100M, 500M and 1G) Verify the data files and their sizes by doing a</td>
</tr>
<tr class="even">
<td>$ ls -lh</td>
</tr>
<tr class="odd">
<td>We are going to use these files as input</td>
</tr>
</tbody>
</table>
<h2 id="step-7-do-wordcount-on-larger-file">STEP 7: Do wordcount on larger file</h2>
<p>Load one of the larger files (100M + )</p>
<pre><code>val f = sc.textFile(&quot;file path&quot;)
// do the wordcount</code></pre>
